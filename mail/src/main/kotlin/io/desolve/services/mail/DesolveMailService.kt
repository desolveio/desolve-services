package io.desolve.services.mail

import jakarta.mail.Authenticator
import jakarta.mail.Message.RecipientType
import jakarta.mail.PasswordAuthentication
import jakarta.mail.Session
import jakarta.mail.Transport
import jakarta.mail.internet.InternetAddress
import jakarta.mail.internet.MimeBodyPart
import jakarta.mail.internet.MimeMessage
import jakarta.mail.internet.MimeMultipart
import java.io.File
import java.util.*
import java.util.concurrent.CompletableFuture

/**
 * @author GrowlyX
 * @since 6/17/2022
 */
object DesolveMailService
{
    private val emailProperties = Properties()
        .apply {
            val properties = File("email.properties")
                .apply scope@{
                    if (exists())
                        return@scope

                    val default =
                        resource("email.properties")

                    createNewFile()
                    appendText("# Content auto-generated by Desolve Mail.")
                    appendText(
                        default.bufferedReader().readText()
                    )
                }
                .inputStream()

            load(properties)
        }

    private val authenticator = object : Authenticator()
    {
        override fun getPasswordAuthentication() =
            PasswordAuthentication(
                "mail.smtp.auth.username".property(),
                "mail.smtp.auth.password".property()
            )
    }

    private val service = Session
        .getInstance(emailProperties, authenticator)
        .apply {
            getTransport("smtp").connect(
                "mail.smtp.host".property(),
                "mail.smtp.port".property().toInt(),
                "mail.smtp.auth.username".property(),
                "mail.smtp.auth.password".property()
            )
        }

    private fun String.property() =
        this@DesolveMailService.emailProperties.getProperty(this)
            ?: throw IllegalArgumentException(
                "Property $this is not available"
            )

    @JvmStatic
    fun main(args: Array<String>)
    {
        val parsed = this.parseTemplate(
            template = "email-verification.html",
            replacements = arrayOf(
                "user" to "Growly",
                "registerUrl" to "https://v1.desolve.io"
            )
        )

        this.sendEmail(
            subject = "[Desolve] Verification", content = parsed,
            recipients = arrayOf(
                "growlyxdev@gmail.com" to RecipientType.TO
            )
        ).join()
    }

    /**
     * Parse an email template by its identifier.
     * Ensure the template is available as a resource
     * in the templates' directory before attempting to use it.
     *
     * @author GrowlyX
     */
    fun parseTemplate(
        template: String,
        vararg replacements: Pair<String, String>
    ): String
    {
        val resource =
            resource("/templates/$template")

        var content = resource
            .bufferedReader()
            .readLines()
            .joinToString("\n")

        for (replacement in replacements)
        {
            content = content.replace(
                "{${replacement.first}}", replacement.second
            )
        }

        return content
    }

    /**
     * Send an email through our service configuration
     * of Jakarta Mail to a targeted recipient(s).
     *
     * Ensure the email content is served by the
     * [parseTemplate] method, or your own HTML content.
     *
     * We return a [CompletableFuture] and process this
     * asynchronously due to the great amount of time
     * required to properly deliver the email.
     *
     * @author GrowlyX
     */
    fun sendEmail(
        subject: String, content: String,
        vararg recipients: Pair<String, RecipientType>,
    ): CompletableFuture<Unit>
    {
        val message = MimeMessage(service)

        message.setFrom(
            InternetAddress(
                emailProperties.getProperty("mail.smtp.auth.username")
            )
        )

        for (recipient in recipients)
        {
            message.setRecipients(
                recipient.second, InternetAddress
                    .parse(recipient.first)
            )
        }

        val bodyPart = MimeBodyPart()
            .apply {
                setContent(content, "text/html; charset=utf-8")
            }

        message.setContent(
            MimeMultipart().apply {
                addBodyPart(bodyPart)
            }
        )

        message.subject = subject

        return CompletableFuture
            .supplyAsync {
                Transport.send(message)
            }
            .exceptionally {
                it.printStackTrace()
            }
    }
}
